{
    "id":2,
    "header":"Ternary operator in Haskell",
    "content":"<p>Some time ago I tried to implement a ternary operator in Haskell. The reason why I decided to write a blog post about it is because I used some neat techniques to achieve it. I think these features would be interesting for people who want to know more about functional programming.</p><br /><p>Some people would say there is a ternary operator in the form <span class=\"code haskell\">if cond then a else b</span>. But my point was to make a ternary operator the way it is implemented in languages like PHP or JavaScript i. e. <span class=\"code haskell\">cond ? a : b</span>.</p><br /><span class=\"note\"><p>For those who are not familiar with Haskell:<ul><li>Functions in Haskell are defined in a form: <span class=\"code haskell\">funcName arg1 arg2  = function body</span></li><li>You can use some non-alphanumeric symbols as names to create operator functions. You need to define them in brackets, for example: <span class=\"code haskell\">(?) arg1 arg2  = body</span>.</li><li>You can define them with infix notation, without brackets: <span class=\"code haskell\">arg1 ? arg2 = body</span> as well as use them like <span class=\"code haskell\">1 ? 2</span>. In fact, operators like + are functions that are used the infix way.</li></ul></p></span><br /><p>First of all, I couldn't use neither \":\" nor \";\" - former is a data constructor for lists but latter is a keyword used to separate statements. I chose\".:\" instead of \":\" but I'm sure there is some way to overload \":\" somehow.</p><br /><p>Next, I needed to figure out how to build functions that would make ternary operator work. The idea is that \"?\" operator should accept two parameters - conditional Boolean parameter and a pair of statements (a,b), and \".:\" operator will combine two statements into a pair. So, (?) function may look like this:</p><pre>(?) cond pair = if cond then fst pair else snd pair</pre><p><span class=\"note\">Functions fst and snd return first and second element of a pair respectively.</span></p><br /><p>This function works but looks ugly and not very Haskell-ish. Lets make it a bit prettier. There are several ways, for example, we can get rid of fst/snd usage via pattern matching:</p><pre>(?) cond (a,b) = if cond then a else b</pre><p>A little bit better but still, something isn't right. Let's try something else - let's match a condition:</p><pre>(?) True  pair = fst pair\n(?) False pair = snd pair</pre><p>Nice, we got rid of <span class=\"code haskell\">if .. then .. else</span> clause. But still, we have some ways to improve this code. First of all, let's think about False case. We can actually say: we return the first element when condition is true, and the second in any other case. That means, instead of False, we can use the _ keyword which means we completely ignore value of this argument (and won't create reference for it):</p><pre>(?) True pair = fst pair\n(?) _    pair = snd pair</pre><p>And last but not least, we can use <a target=\"_blank\" href=\"https://wiki.haskell.org/Eta_conversion\">eta-reduction</a>. Eta-reduction is a process that drops the <a target=\"_blank\" href=\"https://en.wikipedia.org/wiki/Lambda_calculus#Lambda_terms\">abstraction</a> over a function. For example, we have a function:</p><pre>foo a = do_something a</pre><p>This reads as: function foo takes an argument a and does_something with it.</p><p>After reducing an abstraction it will look like this:</p><pre>foo = do_something</pre><p>and reads as: function foo does_something.</p><br/><p>Eta-reduction helps programmer to think about what functions do rather than about data movement. It's so called <a target=\"_blank\" href=\"https://wiki.haskell.org/Pointfree\">pointfree</a> programming style, and is considered a good practice. Pointfree can lead to better, cleaner and more efficient code, however, in some cases overuse of pointfree style can make your code less readable.</p><br /><p>Let's see how we can apply this technique in our case:</p><pre>(?) True = fst\n(?) _    = snd</pre><p>Looks pretty good now. We've made the first part of ternary operator.</p><br /><p>Now, let's make the second part - (.:) function. It must get two arguments and combine them into pair:</p><pre>(.:) a b = (a,b)</pre><p>Here we can eta-reduce as well. In fact, there is a built-in function in Haskell that returns a pair. The function is <span class=\"code haskell\">(,) a b</span>, and <span class=\"code haskell\">(a,b)</span> notation is just an infix way to call that function. In our case we can tell that our function (.:) is equivalent to (,). Fortunately, Haskell will understand this literally:</p><pre>(.:) = (,)</pre><br /><p>Finally, to use our operators in a form <span class=\"code haskell\">cond ? a .: b</span> and to make sure compiler understands us right, we need to define precedence level for (?). It's quite clear that (.:) must have higher level than (?), because we need to get our pair first and then pass it as argument to (?). If we won't do this, compiler won't know in what order to call functions and will probably try to call <span class=\"code haskell\">(cond ? a) .: b</span> instead of <span class=\"code haskell\">cond ? (a .: b)</span>, and this will trigger a type mismatch error. Also there could be some compare operators in condition expression, like <span class=\"code haskell\">1 == 1</span> and they will also conflict with (?). To avoid this we will set the weakest precedence level for (?):</p><pre>infixr 0 ?</pre><br /><p>The final code is:</p><pre>infixr 0 ?\n(?) True = fst\n(?) _    = snd\n\n(.:) = (,)\n\nmain = do\n    print $ 1 == 1 ? \"a\" .: \"b\"\n    print $ 1 == 2 ? \"a\" .: \"b\"</pre><br /><p>This code will output:</p><pre>\"a\"\n\"b\"</pre><br /><br />",
    "url":"ternary_operator_in_haskell",
    "user":"Aleksejs",
    "date":"13 01 2016"
}
